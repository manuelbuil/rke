# Contributing to RKE #

Thanks for taking the time to contribute to RKE!

### Opening PRs and organizing commits
PRs should generally address only 1 issue at a time. If you need to fix two bugs, open two separate PRs. This will keep the scope of your pull requests smaller and allow them to be reviewed and merged more quickly.

Each PR needs to be linked to a Github issue in [rancher project](https://github.com/rancher/rancher) which provides as much detail as possible on the change and its motivation. If it is a bug fix, please describe how to reproduce it in the issue. Make the Team or Project Manager aware of the GitHub issue so that they can set the correct milestone. Milestones are very important for the release and QA tracking. Milestones follow the convention: `$RANCHERVERSION-KDM-$MONTH-$YEAR-patches, e.g. `v2.7-KDM-Nov-2023-patches`.

Generally, pull requests should consist of a single logical commit. However, if your PR is for a large feature, you may need a more logical breakdown of commits. This is fine as long as each commit is a single logical unit. Changes generated by `go mod tidy` or `go generate` should go in separate commits.

Pull requests should target the release/vX.Y branch instead of master. The latest code in RKE is included in such release branches.

### Writing good commit messages
As the change is already well described in the GitHub issue and the PR, Git commit messages can be short or even empty, as long as the title of the commit can easily summarize what the change.

### Reviewing, addressing feedback, and merging
Generally, pull requests need two approvals from maintainers to be merged.

When addressing review feedback, it is helpful to the reviewer if additional changes are made in new commits. This allows the reviewer to easily see the delta between what they previously reviewed and the changes you added to address their feedback. Once positively reviewed, those commits should be squashed into one.

Once a PR has at least two approvals, it can be merged. Here’s how the merge should be handled:
- If the PR is a single logical commit, the merger should use the “Rebase and merge” option. This keeps the git commit history very clean and simple and eliminates noise from "merge commits."
- If the PR is more than one logical commit, the merger should use the “Create a merge commit” option.
- If the PR consists of more than one commit because the author added commits to address feedback, the commits should be squashed into a single commit (or more than one logical commit, if it is a big feature that needs more commits). Remember that `go mod tidy` or `go generate` should go in separate commits, hence do not swaush in that case. Squashing of commits can be achieved in one of two ways:
  - The merger can use the “Squash and merge” option. If they do this, the merger is responsible for cleaning up the commit message according to the previously stated commit message guidance.
  - The pull request author, after getting the requisite approvals, can reorganize the commits as they see fit (using, for example, git rebase -i) and re-push.

Once the PR is merged, please change the status of the linked issue in [rancher project](https://github.com/rancher/rancher) to "[zube] To Test". In the following days, the QA team will run tests and process the PR to verify that no regressions were introduced. Please be alert on the issue as the QA team might ask questions related to the PR. 

### Backports

#### RKE code

To understand how backports should be pulled through, RKE project releases and what is included in each release should be described. RKE in general maintains two tracks in parallel which are differentiated by the minor version. Each of these tracks are developped in two different GitHub branches:
* release/v1.x, (for example [release/v1.5](https://github.com/rancher/rke/tree/release/v1.5)
* release/v1.(x-1) (for example [release/v1.4](https://github.com/rancher/rke/tree/release/v1.4)

Each track releases an RKE binary. Each release of RKE officially supports a few Kubernetes versions. Some versions are shared by both tracks but normally the track with the higher minor version includes at least one newer Kubernetes version. For example, as it can be observed in [release v1.4.11](https://github.com/rancher/rke/releases/tag/v1.4.11), the following Kubernetes versions are supported:
* v1.26.9-rancher1-1
* v1.25.14-rancher1-1
* v1.24.17-rancher1-1
* v1.23.16-rancher2-3

whereas [release v1.5.0](https://github.com/rancher/rke/releases/tag/v1.5.0) includes:
* v1.25.14-rancher1-1
* v1.26.9-rancher1-1
* v1.27.6-rancher1-1

If a Kubernetes version is supported, that means we can deploy a cluster with that Kubernetes version using the binary included in that RKE release.

When doing a commit in RKE code, we must carefully think if we want that commit in both tracks and hence backported. Sometimes, there is a reason to no backport it, for example a flag, that we would like to limit to only the newer track. However, that is exceptional and normally commits end up in both branches as a way to reduce the differences between those and simplify RKE maintainability. Therefore, usually we backport a commit between both RKE tracks. In that case, the following steps should be applied:

* Create an Issue in rancher/rancher GitHub project for Project Managers and QA to track the commit. Each RKE1 release track is mapped to one milestone in rancher/rancher GitHub project. Set the decided milestone for release/v1.x in the issue.
* Create another Issue in rancher/rancher and specify in the description that it is a backport of the previous commit. Set the decided milestone for release/v1.(x-1) in the issue
* Create the PR with the commit in branch release/v1.x and in the description, link the newly created issue
* Cherry-pick the commit in branch release/v1.(x-1) and in the description, link the created issue for that RKE track.

A commit is normally available in all supported Kubernetes versions of the release unless scoped in the code to a specific version. Here are two examples for this:
* Available in all supported Kubernetes versions: https://github.com/rancher/rke/commit/1dad2582e1efe5564b6d1a7385afad70d5dbd1f7
* Scoped to a specific version: https://github.com/rancher/rke/commit/feca6a3048c1f8c9031ab2849a46c46a7ea1d673

Note that in the scoped case, there is a check on the version, which is normally fetched by executing the line `util.StrToSemVer(k8sVersion)`, [here an example](https://github.com/rancher/rke/blob/release/v1.5/cluster/validation.go#L752)


#### Add-ons

RKE consumes different add-ons to deploy a usable Kubernetes cluster, e.g. CNI plugins. Typically all Kubernetes versions include the same range of add-ons but use different add-on versions. For example, for the flannel add-on:
* In v1.26.8-rancher1-1 flannel version is `v0.21.4`
* In v1.24.17-rancher1-1 flannel version is `v0.15.1`

What add-on version is used per RKE Kubernetes release is mapped in the `data.json` file, which is a file autogenerated by querying [KDM](https://github.com/rancher/kontainer-driver-metadata) releases. Especifically, the information is in [templates.go](https://github.com/rancher/kontainer-driver-metadata/blob/dev-v2.8/pkg/rke/templates/templates.go). Read the RKE [README.md](https://github.com/rancher/rke/blob/release/v1.4/README.md) for more information.

If we would like to use a new add-on version in the next Kubernetes version, we need to make sure that the next KDM release includes the desired mapping. After KDM gets released, RKE project will be able to use that mapping.
